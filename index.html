<!DOCTYPE html>
<html>
	<head>
	
<script>

var Stat = {};
Stat.Create = function(inMin, inLevel, inMax)
{
	var obj = {};
	obj.Min = 0;
	obj.Max = 100;
	obj.Level = 50;
	obj.Handlers = [];
};
Stat.Listen = function(inStat, inHandler)
{
	inStat.Handlers.push(inHandler);
};
Stat.Change = function(inStat, inAmount)
{
	var was, is;
	was = inStat.Level;
	inStat.Level += inAmount;
	if(inStat.Level < inStat.Min)
	{
		inStat.Level = inStat.Min;
	}
	if(inStat.Level > inStat.Max)
	{
		inStat.Level = inStat.Max;
	}
	is = inStat.Level;
	
	var i;
	for(i=0; i<inStat.Handlers.length; i++)
	{
		inStat.Handlers[i](inStat, is-was);
	}
	
};

var Utilities = {};
Utilities.SetID = function(inObj)
{
	inObj.ID = Math.floor(Math.random()*100000);
};


var Energy = {};
Energy.Settings = {};
Energy.Settings.DefaultLevel = 3;
Energy.Create = function()
{
	var obj = {};
	
	obj.Level = Energy.Settings.DefaultLevel;
	
	return obj;
};


var Ability = {};
Ability.Create = function(inVector, inType)
{
	var obj = {};
	obj.Vector = inVector;
	//array of integers.
	//when added, they must equal 0.
	//no value (positive or negative) can exceed the total amount of energy in the world: World.Energies.length * Energy.Settings.DefaultLevel

	obj.Type = inType;
	
	//derived values
	obj.Subtractions = []; // these parts of the vector are used to check whether or not the ability can be used
	obj.Power = 0; // "power" of the ability, based on how much energy is moving around
	var i;	
	for(i=0; i<obj.Vector.length; i++)
	{
		if(obj.Vector[i] < 0)
		{
			obj.Subtractions.push({Index:i, Amount:obj.Vector[i]});
			obj.Power -= obj.Vector[i];
		}
	}
	
	ability.Charge = false;
	
	return obj;
};
// Check to see if performing an ability would cause one of the energy levels to go below 0
Ability.Check = function(inAbility)
{
	var i;
	var current;
	for(i=0; i<inAbility.Subtractions.length; i++)
	{
		current = inAbility.Subtractions[i];
		//current.Amount will be negative
		if(World.Energies[current.Index].Level + current.Amount < 0)
		{
			return false;
		}
	}
	return true;
};
// Charge the ability for use
Ability.Charge = function(inAbility)
{
	var i;
	for(i=0; i<inAbility.Vector.length; i++)
	{
		World.Energies[i].Level += inAbility.Vector[i];
	}
	inAbility.Charged = true;
};
// creates an "effect" that will be used on onther players
Ability.Use = function(inPlayer, inAbility, inTargets, inDuration)
{
	var e = Effect.Create(inPlayer.Empowered.Level, inDuration, inTargets);
};


var Effect = {};
Effect.Type = {};
Effect.Type.Damage = 0;
Effect.Type.Heal = 1;
Effect.Spread = function(inPower, inDivisions)
{
	return (inPower + 1.1*inDivisions)/inDivisions
};
Effect.Create = function(inPlayer, inAbility)
{
	var obj = {};
	
	obj.Time = 0;
	obj.Age = inDuration;

	if(inTargets > 1)
		obj.ScalarSpatial = 1/(inTargets*0.9);
	else
		obj.ScalarSpatial = 1;
	
	if(inDuration > 1)
		obj.ScalarTemporal = 1/(inDuration*0.9);
	else
		obj.ScalarTemporal = 1;
	
	obj.Power = inPower*obj.ScalarSpatial*obj.ScalarTemporal;
	
	return obj;
};
Effect.Apply = function(inEffect, inPlayer)
{
	
};


var Group = {};
Group.Create = function()
{
	var obj = {};
	obj.Members = [];
	return obj;
};


var Player = {};
Player.MaxHealth = 100;
Player.Create = function(inGroup)
{
	var obj = {};
	
	obj.Group = inGroup;
	obj.Group.Members.push(obj);
	
	obj.Health = Player.MaxHealth;
	obj.Shield = 0;
	obj.Weakness = 0;
	
	obj.Abilities = [];
	obj.Targets = [];
	obj.Effects = [];
	
	obj.Empowered = World.Energies[0]; // (increases created effects)
	obj.Inhibited = World.Energies[0]; // (increases incoming negative effects / decreases incoming positive effects)
	
	obj.Actions = 0;
	obj.Dead = false;
	
	return obj;
};
Player.PerformAction = function(inPlayer)
{
	obj.Actions--;
	if(obj.Actions <= 0)
		Turn.Advance();
};
Player.Effect = {};
Player.Effect.Damage = function(inPlayer, inAmount)
{
	inPlayer.Health -= inAmount;
	if(inPlayer.Health < 0)
	{
		inPlayer.Health = 0;
		inPlayer.Dead = true;
	}
};
Player.Effect.Heal = function(inPlayer, inAmount)
{
	inPlayer.Health += inAmount;
	if(inPlayer.Health > Player.MaxHealth)
	{
		inPlayer.Health = Player.MaxHealth;
	}
};


var Round = {};
Round.Active = false; // the current round
Round.Player = false; // the current player within the round
Round.History = []; // log of rounds
Round.Groups = []; // the teams at play
Round.Create = function()
{
	var obj = {};
	obj.Members = [];
	obj.Index = 0;
	
	var i, j;
	var alive = [];
	var index;
	for(i=0; i<Round.Groups.length; i++)
	{
		for(j=0; j<Round.Groups[i].length; j++)
		{
			if(!Round.Groups[i].Members[j].Dead)
				alive.push(Round.Groups[i].Members[j]);
		}
	}
	while(alive.length != 0)
	{
		index = Math.floor(alive.length*Math.random());
		obj.Members.push( alive.splice(index, 1)) );
	}
	Round.History.push(obj);
	Round.Active = obj;
	return obj;
};
Round.Advance = function()
{
	Round.Active.Index++;
	
	if(Round.Active.index >= Round.Active.length)
	{
		Round.Create();
		return;
	}
	
	if(Round.Members[Round.Active.Index].Dead)
	{
		Round.Advance();
	}
	
	Round.Player = Round.Members[Round.Active.Index]
	Round.Player.Actions = 3;
	
};

</script>

<script>

var World = {};
World.Energies = [];
World.Groups = [];

World.Energies.push(Energy.Create());
World.Energies.push(Energy.Create());
World.Energies.push(Energy.Create());

World.Groups.push(Group.Create());
World.Groups.push(Group.Create());

var p1 = Player.Create(World.Groups[0]);
var p2 = Player.Create(World.Groups[1]);

var a1 = Ability.Create([-1, 1, 0], Ability.Types.Damage, 1, 1);
var a2 = Ability.Create([0, -1, 1], Ability.Types.Damage, 1, 1);
var a3 = Ability.Create([1, 0, -1], Ability.Types.Damage, 1, 1);

p1.Abilities = [a1, a2, a3];
p2.Abilities = [a1, a2, a3];

</script>

	</head>
	<body>
		
	</body>
<html>