<!DOCTYPE html>
<html>
	<head>
	
<script>

var Stat = {};
Stat.Create = function(inMin, inLevel, inMax)
{
	var obj = {};
	obj.Min = 0;
	obj.Max = 100;
	obj.Level = 50;
	obj.Handlers = [];
};
Stat.Listen = function(inStat, inHandler)
{
	inStat.Handlers.push(inHandler);
};
Stat.Unlisten = function(inStat, inHandler)
{
	var i;
	for(i=0; i<inStat.Handlers.length; i++)
	{
		if(inStat.Handlers[i] === inHandler)
		{
			inStat.Handlers.splice(i, 1);
			return;
		}
	}
};
Stat.Relative = function(inStat, inAmount)
{
	Stat.Absolute(inStat, inStat.Level+inAmount);
};
Stat.Absolute = function(inStat, inAmount)
{
	var was, difference, i;
	was = inStat.Level;
	inStat.Level = inAmount;
	if(inStat.Level < inStat.Min)
	{
		inStat.Level = inStat.Min;
	}
	if(inStat.Level > inStat.Max)
	{
		inStat.Level = inStat.Max;
	}
	difference = inStat.Level-was;
	for(i=0; i<inStat.Handlers.length; i++)
	{
		inStat.Handlers[i](inStat, difference);
	}	
};

/*
An Ability has the power to alter energy levels, causing the ability to "charge."
A charged ability can then be used to effect other players, consuming the charge.

Both the charging of and use of Abilities cause the player to consume action points for their turn.

With each use, the player can modify the Ability's effect to be spread out accross multiple targets and/or to be applied over time.
Dividing up the effect this way causes it to have a different strength.
The total amount of power is scaled by 10% for each division, and then the total is split evenly among the divisions:

Dealing damage to 2 targets over 3 turns will result in 60% more damage dealt in total, at the cost of only dealing one-sixth of this damage to each player each turn.
The same holds true for dealing damage to 3 targets over 2 turns.

Dealing damage to 1 target over 2 turns will result in 20% more damage, at the cost of dealing only one-half of this damage each turn.
The same holds true for dealing damage to 2 targets this turn only.

The strength of the effect is modified by the player's Empowered stat.
The effect strength is calculated only once when the effect is created and lasts the duration of the effect.

Applications of the effect to a target player are modified by the target player's Inhibited stat.
This modification is re-calculated each time the effect is applied to it's target.
*/
var Ability = {};
Ability.Create = function(inVector, inType)
{
	var obj = {};
	obj.Vector = inVector;
	//array of integers.
	//when added, they must equal 0.
	//no value (positive or negative) can exceed the total amount of energy in the world: World.Energies.length * Energy.Settings.DefaultLevel

	obj.Type = inType;
	
	//derived values
	obj.Subtractions = []; // these parts of the vector are used to check whether or not the ability can be used
	obj.Power = 0; // "power" of the ability, based on how much energy is moving around
	var i;	
	for(i=0; i<obj.Vector.length; i++)
	{
		if(obj.Vector[i] < 0)
		{
			obj.Subtractions.push({Index:i, Amount:obj.Vector[i]});
			obj.Power -= obj.Vector[i];
		}
	}
	
	obj.Charge = Stat.Create(0, 1, 0);
	
	return obj;
};
// Check to see if performing an ability would cause one of the energy levels to go below 0
Ability.Check = function(inAbility, inEnergies)
{
	var i;
	var current;
	for(i=0; i<inAbility.Subtractions.length; i++)
	{
		current = inAbility.Subtractions[i];
		if(inEnergies[current.Index].Level < -current.Amount)
		{
			return false;
		}
	}
	return true;
};
// Charge the ability for use
Ability.Charge = function(inAbility, inEnergies)
{
	var i;
	for(i=0; i<inAbility.Vector.length; i++)
	{
		Stat.Relative(inEnergies[i], inAbility.Vector[i]);
	}
	inAbility.Charged = true;
};
Ability.Use = function(inPlayer, inAbility, inTargets, inDuration)
{
	var i;
	var effect;
	for(i=0; i<inTargets.length; i++)
	{
		effect = Effect.Create(inAbility.Power, inTargets.length, inDuration, inTargets[i].Stats.Health);
		Effect.Apply(effect);
		
		inTargets[i].Effects.push(effect);
	}
	inAbility.Charged = false;
};

/*
Effects are created solely from Abilities 
*/
var Effect = {};
Effect.Create = function(inPower, inSpatialDivisions, inTemporalDivisions, inStat)
{
	var obj = {};
	
	obj.Lifespan = inTemporalDivisions;
	obj.Age = 0;
	
	obj.Divisions = 0;
	obj.Power = inPower;
	
	if(inSpatialDivisions > 1)
		obj.Divisions += inSpatialDivisions;
		
	if(inTemporalDivisions > 1)
		obj.Divisions += inTemporalDivisions;	
	
	if(obj.Divisions != 0)
		obj.Power *= (1 + 0.1*obj.Divisions)/obj.Divisions;
	
	obj.Stat = inStat;
	
	return obj;
};
Effect.Apply = function(inEffect)
{
	inEffect.Age++;
	if(inEffect.Age == inEffect.Lifespan)
	{
		
	}
	
	Stat.Relative(obj.Stat, inEffect.Power);
};


var Group = {};
Group.Create = function()
{
	var obj = {};
	obj.Members = [];
	return obj;
};


var Player = {};
Player.Create = function(inGroup)
{
	var obj = {};
	
	obj.Stats = {};
	obj.Stats.Health = Stat.Create(0, 100, 100);
	obj.Stats.Shield = Stat.Create(0, 100, 100);
	obj.Stats.Action = Stat.Create(0, 3, 3);
	obj.Stats.Empowered = Stat.Create(0, 100, 0);
	obj.Stats.Inhibited = Stat.Create(0, 100, 0);
	
	obj.Group = inGroup;
	obj.Group.Members.push(obj);

	obj.Abilities = [];
	obj.Targets = [];
	obj.Effects = [];
	
	return obj;
};
Player.PerformAction = function(inPlayer)
{
	Stat.Relative(inPlayer.Stats.Action, -1);
};


var Round = {};
Round.Active = false; // the current round
Round.Player = false; // the current player within the round
Round.History = []; // log of rounds
Round.Groups = []; // the teams at play
Round.Create = function()
{
	var obj = {};
	obj.Members = [];
	obj.Index = 0;
	
	var i, j;
	var alive = [];
	var index;
	for(i=0; i<Round.Groups.length; i++)
	{
		for(j=0; j<Round.Groups[i].length; j++)
		{
			if(!Round.Groups[i].Members[j].Dead)
				alive.push(Round.Groups[i].Members[j]);
		}
	}
	while(alive.length != 0)
	{
		index = Math.floor(alive.length*Math.random());
		obj.Members.push( alive.splice(index, 1)) );
	}
	Round.History.push(obj);
	Round.Active = obj;
	return obj;
};
Round.Advance = function()
{
	Round.Active.Index++;
	
	if(Round.Active.index >= Round.Active.length)
	{
		Round.Create();
		return;
	}
	
	if(Round.Members[Round.Active.Index].Dead)
	{
		Round.Advance();
	}
	
	Round.Player = Round.Members[Round.Active.Index]
	Round.Player.Actions = 3;
	
};


</script>

<script>

var World = {};
World.Energies = [];
World.Groups = [];

var i;
var count = 3;
var startingLevel = 3;
for(i=0; i<count; i++)
{
	World.Energies.push(Stat.Create(0, startingLevel*count, startingLevel));	
}


World.Groups.push(Group.Create());
World.Groups.push(Group.Create());

var p1 = Player.Create(World.Groups[0]);
var p2 = Player.Create(World.Groups[1]);

var a1 = Ability.Create([-1, 1, 0], Ability.Types.Damage, 1, 1);
var a2 = Ability.Create([0, -1, 1], Ability.Types.Damage, 1, 1);
var a3 = Ability.Create([1, 0, -1], Ability.Types.Damage, 1, 1);

p1.Abilities = [a1, a2, a3];
p2.Abilities = [a1, a2, a3];

</script>

	</head>
	<body>
		
	</body>
<html>